# CMINUS

## 一、程序实现功能说明

本程序实现了 CMINUS 语言的词法分析与语法分析，能够检测如下类型的错误，并对部分重要特性进行了扩展和个性化处理。

### 1. 错误处理功能

#### 1.1 词法错误（错误类型A）
- **未定义字符和不符合法则的字符**：词法分析器（`src/lexer.l`）通过正则定义和默认规则自动识别非法字符，遇到不符合CMINUS词法的内容时会调用`lex_error`进行报错。

#### 1.2 语法错误（错误类型B）
- **语法分析器**（`src/parser.y`）采用Bison编写，通过规则和错误处理分支（如`Exp LB error RB`，调用`syn_error`）精确定位语法错误，并输出错误信息，便于调试和测试。

### 2. 关键特性实现

#### 2.1 八进制数与十六进制数识别
- 词法规则中，八进制（`0[0-7]+`）和十六进制（`0[xX][0-9a-fA-F]+`）分别有专门的正则，统一由`{INT}`规则识别。对于不合法的八进制（如`09`）和十六进制（如`0x1G`），不会匹配`{INT}`，而会落入错误处理分支，提示词法错误。

#### 2.2 指数形式浮点数识别
- 浮点数规则`{FLOAT}`支持三种形式（如`1.05e-4`、`.1e+2`、`3e3`），若输入如`1.05e`等不合法指数形式，将不会被匹配，落入错误分支触发词法错误提示。

#### 2.3 注释识别与错误处理
- 支持`//`单行注释和`/*...*/`多行注释，通过词法状态机（`%x COMMENT`）精确处理注释内容，遇到未闭合的多行注释（如`/*`未配对`*/`），会在文件结束时报错并输出提示信息（如`Error: Unterminated comment started at line X`）。

#### 2.4 其它支持
- 支持常见的 CMINUS 关键字、操作符、标识符等，语法分析器构建语法树（AST）并可打印分析树结构，便于调试与测试。

---

## 二、编译方法说明

本项目提供了完整的自动化编译脚本，推荐使用`make`进行编译。

### 1. 依赖环境

- Ubuntu 或类 Unix 环境
- GCC（C99）
- Flex
- Bison
- Make

### 2. 编译步骤

#### 方式一：本地编译
1. 安装依赖（如未安装）：
   ```sh
   sudo apt-get install gcc make flex bison
   ```
2. 在项目根目录下执行：
   ```sh
   make
   ```
   编译成功后，生成目标文件 `build/cc`。

3. 运行测试用例：
   ```sh
   make test
   ```

#### 方式二：使用 Docker 编译
- 项目自带 `Dockerfile`，可使用如下命令一键编译并进入容器环境：
  ```sh
  docker build -t cminus .
  docker run -it --rm cminus
  ```
- 容器内已自动执行`make`，也可手动运行测试。

#### 方式三：CI 自动化
- 项目集成 GitHub Actions，自动在主分支进行编译和测试，保证主分支代码持续可用。

---

## 三、程序亮点与创新点

### 1. 词法与语法错误精细化处理
- 使用独立的`lex_error`和`syn_error`接口，所有错误输出均精确到行，且信息友好；
- 语法分析器中对某些常见易错点（如数组下标、括号等）专门给出定制化错误提示，便于定位和修复。

### 2. 注释处理的健壮性
- 多行注释采用 Flex 状态机制处理，能够正确支持跨行、嵌套边界检查，并对未闭合注释给出行号精准的错误提示，极大便利了调试。

### 3. 支持多种数值格式的词法自动识别
- 八/十六进制与浮点数的正则表达式设计简洁高效，既保证正确识别，又能有效过滤错误格式，实现了对复杂数字形式的自动区分与错误捕获。

### 4. 构建抽象语法树（AST）
- 采用面向对象风格的AST节点生成（`new_token`/`new_nonterm`），便于后续语义分析和中间代码生成模块扩展。

### 5. 完整自动化与测试保障
- Makefile 支持一键编译、测试和清理，Dockerfile 保证环境一致性，CI 流程自动检测主分支的构建和功能正确性，大幅提升项目工程化水平和可移植性。

---

## 四、结论

本项目不仅实现了 CMINUS 的标准词法、语法分析与错误处理，还在工程化和用户体验上做了诸多优化。对于复杂输入（如各种注释、特殊数字格式、易错语法结构）均能给出详尽的报错信息。推荐测试时重点关注各类错误边界条件，体验程序的健壮性和易用性。

